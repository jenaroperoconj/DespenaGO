import { Injectable } from '@angular/core';
import { createClient, SupabaseClient  } from '@supabase/supabase-js';

@Injectable({
  providedIn: 'root',
})
export class SupabaseService {
  private supabase: SupabaseClient;

  constructor() {
    this.supabase = createClient(
      'https://qiatmsfnhjqfdbxfokig.supabase.co',
      'eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6InFpYXRtc2ZuaGpxZmRieGZva2lnIiwicm9sZSI6ImFub24iLCJpYXQiOjE3NDY3NjAzODMsImV4cCI6MjA2MjMzNjM4M30.O5g4ovc0N-XYecog0bsJJP2EmNYi2iTtqT_c0odMBng'
    );
  }

  async login(email: string, password: string) {
    return this.supabase.auth.signInWithPassword({ email, password });
  }  async signUp(email: string, password: string, nombre: string) {
    const { data, error } = await this.supabase.auth.signUp({ 
      email, 
      password,
      options: {
        emailRedirectTo: `${window.location.origin}/login?verified=true`,
        data: {
          nombre: nombre
        }
      }
    });

    if (error) {
      // Manejo espec√≠fico para diferentes tipos de errores
      if (error.message.includes('User already registered')) {
        throw new Error('Este correo electr√≥nico ya est√° registrado');
      } else if (error.message.includes('Invalid email')) {
        throw new Error('El formato del correo electr√≥nico no es v√°lido');
      } else if (error.message.includes('Password should be at least')) {
        throw new Error('La contrase√±a debe tener al menos 6 caracteres');
      } else if (error.message.includes('Unable to validate email address')) {
        throw new Error('No se pudo validar el correo electr√≥nico. Verifica que sea correcto');
      } else if (error.message.includes('For security purposes')) {
        throw new Error('Por seguridad, debes esperar antes de intentar registrarte nuevamente');
      }
      throw error;
    }

    const userId = data.user?.id;
    if (!userId) throw new Error('No se pudo obtener el ID del usuario');

    // Solo insertar en la tabla usuarios si el usuario fue creado exitosamente
    if (data.user) {
      const { error: insertError } = await this.supabase
        .from('usuarios')
        .insert({ id: userId, email, nombre });

      if (insertError) {
        console.warn('Error al insertar usuario en tabla personalizada:', insertError);
        // No lanzar error aqu√≠ para no bloquear el registro
      }
    }

    return data;
  }
  async resendConfirmation(email: string) {
    const { data, error } = await this.supabase.auth.resend({
      type: 'signup',
      email: email,
      options: {
        emailRedirectTo: `${window.location.origin}/login?verified=true`
      }
    });

    if (error) {
      if (error.message.includes('For security purposes')) {
        throw new Error('Por seguridad, debes esperar antes de solicitar otro correo');
      } else if (error.message.includes('Email not confirmed')) {
        throw new Error('El correo a√∫n no ha sido confirmado');
      } else if (error.message.includes('Invalid email')) {
        throw new Error('Correo electr√≥nico no v√°lido');
      }
      throw error;
    }

    return data;
  }

  // Nuevo m√©todo para verificar el estado del email
  async checkEmailVerificationStatus(email: string) {
    try {
      const { data, error } = await this.supabase.auth.getUser();
      if (error) throw error;
      
      return {
        isVerified: data.user?.email_confirmed_at !== null,
        email: data.user?.email,
        lastSignInAt: data.user?.last_sign_in_at
      };
    } catch (error) {
      console.error('Error checking verification status:', error);
      return { isVerified: false, email: null, lastSignInAt: null };
    }
  }

  // M√©todo para configurar email redirect URL din√°micamente
  private getEmailRedirectUrl(): string {
    const baseUrl = window.location.origin;
    return `${baseUrl}/login?verified=true`;
  }

  async logout() {
    return this.supabase.auth.signOut();
  }

  getUser() {
    return this.supabase.auth.getUser();
  }
  async isLoggedIn(): Promise<boolean> {
    const { data } = await this.supabase.auth.getSession();
    return !!data.session;
  }
  get client() {
    return this.supabase;
  }
  
  async crearDespensa(nombre: string) {
    const user = await this.supabase.auth.getUser();
    if (!user.data.user) throw new Error('No autenticado');

    // 1. Crear la despensa
    const { data: despensa, error: errorDespensa } = await this.supabase
      .from('despensas')
      .insert({
        nombre,
        propietario_id: user.data.user.id
      })
      .select()
      .single();

    if (errorDespensa) throw errorDespensa;

    // 2. Insertar acceso del usuario como propietario
    const { error: errorAcceso } = await this.supabase
      .from('accesos_despensa')
      .insert({
        usuario_id: user.data.user.id,
        despensa_id: despensa.id,
        rol: 'propietario' // o 'due√±o' seg√∫n lo que prefieras
      });

    if (errorAcceso) throw errorAcceso;

    return despensa;
  }  async obtenerDespensasUsuario() {
    const user = await this.supabase.auth.getUser();
    const userId = user.data.user?.id;
    if (!userId) throw new Error('No autenticado');

    const { data, error } = await this.supabase
      .from('accesos_despensa')
      .select(`
        rol,
        despensas (
          id,
          nombre,
          created_at
        )
      `)
      .eq('usuario_id', userId)
      .order('created_at', { foreignTable: 'despensas', ascending: false });

    if (error) throw error;

    // Obtener el conteo de productos para cada despensa
    const despensasConConteo = await Promise.all(
      (data || []).map(async (item: any) => {
        if (!item.despensas) return item;
        
        const { count, error: errorConteo } = await this.supabase
          .from('producto_despensa')
          .select('*', { count: 'exact', head: true })
          .eq('despensa_id', item.despensas.id)
          .gt('stock', 0); // Solo contar productos con stock > 0

        if (errorConteo) {
          console.warn('Error al contar productos para despensa', item.despensas.id, errorConteo);
        }

        return {
          ...item,
          despensas: {
            ...item.despensas,
            cantidadProductos: count || 0
          }
        };
      })
    );

    return despensasConConteo;
  }
  async agregarProductoADespensa(despensaId: string, datos: {
    nombre: string;
    categoria?: string;
    origen?: string;
    fecha_vencimiento?: string;
    stock?: number;
  }) {
    // 1. Insertar producto
    const { data: producto, error: errorProd } = await this.supabase
      .from('productos')
      .insert({
        nombre: datos.nombre,
        categoria: datos.categoria || null,
        origen: datos.origen || null,
        fecha_ingreso: new Date().toISOString()
      })
      .select()
      .single();

    if (errorProd) throw errorProd;

    // 2. Asociar a despensa
    const { error: errorAsoc, data: dataAsoc } = await this.supabase
      .from('producto_despensa')
      .insert({
        despensa_id: despensaId,
        producto_id: producto.id,
        stock: datos.stock || 1,
        fecha_vencimiento: datos.fecha_vencimiento || null
      });

    console.log('Resultado de insert en producto_despensa:', dataAsoc, errorAsoc);
  }
  async obtenerProductosDeDespensa(despensaId: string) {
    const { data, error } = await this.supabase
      .from('producto_despensa')
      .select(`
        id,
        stock,
        fecha_vencimiento,
        productos (
          id,
          nombre,
          categoria,
          origen,
          fecha_ingreso
        )
      `)
      .eq('despensa_id', despensaId)
      .order('fecha_vencimiento', { ascending: true });

    if (error) throw error;
    return data;
  }
  async eliminarProductoDeDespensa(productoDespensaId: string) {
    const { error } = await this.supabase
      .from('producto_despensa')
      .delete()
      .eq('id', productoDespensaId);

    if (error) throw error;
  }

  async eliminarDespensa(despensaId: string) {
    // 1. Eliminar productos asociados
    await this.supabase
      .from('producto_despensa')
      .delete()
      .eq('despensa_id', despensaId);

    // 2. Eliminar accesos asociados
    await this.supabase
      .from('accesos_despensa')
      .delete()
      .eq('despensa_id', despensaId);

    // 3. Eliminar la despensa en s√≠
    const { error } = await this.supabase
      .from('despensas')
      .delete()
      .eq('id', despensaId);

    if (error) throw error;
  }

  async editarDespensa(despensaId: string, datos: { nombre?: string }) {
    const { error } = await this.supabase
      .from('despensas')
      .update({ nombre: datos.nombre })
      .eq('id', despensaId);

    if (error) throw error;
  }

  /**
   * Actualiza el stock de un producto en producto_despensa
   */
  async actualizarStockProducto(productoDespensaId: string, nuevoStock: number) {
    const { error } = await this.supabase
      .from('producto_despensa')
      .update({ stock: nuevoStock })
      .eq('id', productoDespensaId);

    if (error) throw error;
  }
  /**
   * Reduce el stock de un producto y retorna el nuevo stock
   */
  async reducirStockProducto(productoDespensaId: string, cantidadReducir: number): Promise<number> {
    // Primero obtener el stock actual
    const { data: producto, error: errorConsulta } = await this.supabase
      .from('producto_despensa')
      .select('stock')
      .eq('id', productoDespensaId)
      .single();

    if (errorConsulta) throw errorConsulta;

    const nuevoStock = Math.max(0, producto.stock - cantidadReducir);
    
    // Actualizar el stock
    const { error: errorUpdate } = await this.supabase
      .from('producto_despensa')
      .update({ stock: nuevoStock })
      .eq('id', productoDespensaId);

    if (errorUpdate) throw errorUpdate;

    return nuevoStock;
  }

  /**
   * Obtiene productos pr√≥ximos a vencer de todas las despensas del usuario
   */  async obtenerProductosProximosAVencer(diasLimite: number = 7): Promise<any[]> {
    const user = await this.supabase.auth.getUser();
    const userId = user.data.user?.id;
    if (!userId) throw new Error('No autenticado');

    // Calcular fecha l√≠mite
    const hoy = new Date();
    const fechaLimite = new Date(hoy);
    fechaLimite.setDate(hoy.getDate() + diasLimite);

    const { data, error } = await this.supabase
      .from('producto_despensa')
      .select(`
        id,
        stock,
        fecha_vencimiento,
        productos (
          id,
          nombre,
          categoria,
          origen
        ),
        despensas!inner (
          id,
          nombre,
          accesos_despensa!inner (
            usuario_id
          )
        )
      `)
      .eq('despensas.accesos_despensa.usuario_id', userId)
      .not('fecha_vencimiento', 'is', null)
      .lte('fecha_vencimiento', fechaLimite.toISOString().split('T')[0])
      .gte('fecha_vencimiento', hoy.toISOString().split('T')[0])
      .gt('stock', 0)
      .order('fecha_vencimiento', { ascending: true })
      .limit(10);

    if (error) throw error;
    console.log('Datos de productos pr√≥ximos a vencer:', data);
    return data || [];
  }

  /**
   * Obtiene estad√≠sticas del usuario (productos totales, despensas, etc.)
   */
  async obtenerEstadisticasUsuario(): Promise<{
    totalProductos: number;
    totalDespensas: number;
    productosVencidos: number;
    productosProximosVencer: number;
  }> {
    const user = await this.supabase.auth.getUser();
    const userId = user.data.user?.id;
    if (!userId) throw new Error('No autenticado');

    const hoy = new Date();
    const fechaLimite = new Date(hoy);
    fechaLimite.setDate(hoy.getDate() + 7);

    // Obtener productos del usuario
    const { data: productos, error } = await this.supabase
      .from('producto_despensa')
      .select(`
        stock,
        fecha_vencimiento,
        despensas!inner (
          accesos_despensa!inner (
            usuario_id
          )
        )
      `)
      .eq('despensas.accesos_despensa.usuario_id', userId)
      .gt('stock', 0);

    if (error) throw error;

    // Obtener despensas del usuario
    const { data: despensas, error: errorDespensas } = await this.supabase
      .from('accesos_despensa')
      .select('despensa_id')
      .eq('usuario_id', userId);

    if (errorDespensas) throw errorDespensas;

    const totalProductos = productos?.length || 0;
    const totalDespensas = despensas?.length || 0;
    
    let productosVencidos = 0;
    let productosProximosVencer = 0;

    productos?.forEach(p => {
      if (p.fecha_vencimiento) {
        const fechaVenc = new Date(p.fecha_vencimiento);
        if (fechaVenc < hoy) {
          productosVencidos++;
        } else if (fechaVenc <= fechaLimite) {
          productosProximosVencer++;
        }
      }
    });

    return {
      totalProductos,
      totalDespensas,
      productosVencidos,
      productosProximosVencer
    };
  }

  /**
   * Obtiene productos con bajo stock (menos de 3 unidades)
   */  async obtenerProductosBajoStock(limite: number = 3): Promise<any[]> {
    const user = await this.supabase.auth.getUser();
    const userId = user.data.user?.id;
    if (!userId) throw new Error('No autenticado');

    const { data, error } = await this.supabase
      .from('producto_despensa')
      .select(`
        id,
        stock,
        fecha_vencimiento,
        productos (
          id,
          nombre,
          categoria,
          origen
        ),
        despensas!inner (
          id,
          nombre,
          accesos_despensa!inner (
            usuario_id
          )
        )
      `)
      .eq('despensas.accesos_despensa.usuario_id', userId)
      .lte('stock', limite)
      .gt('stock', 0)
      .order('stock', { ascending: true })
      .limit(8);

    if (error) throw error;
    console.log('Datos de productos bajo stock:', data);
    return data || [];
  }  /**
   * Busca un usuario por email para invitarlo a colaborar
   * Maneja las pol√≠ticas RLS usando una funci√≥n Supabase
   */
  async buscarUsuarioPorEmail(email: string): Promise<any> {
    // Normalizar el email (quitar espacios y convertir a min√∫sculas)
    const emailNormalizado = email.trim().toLowerCase();
    
    console.log('üîç Buscando usuario con email (RLS-aware):', emailNormalizado);

    try {
      // Intentar primero con una funci√≥n RPC que puede tener permisos elevados
      const { data: rpcResult, error: rpcError } = await this.supabase
        .rpc('buscar_usuario_por_email', { email_busqueda: emailNormalizado });

      if (!rpcError && rpcResult && rpcResult.length > 0) {
        console.log('‚úÖ Usuario encontrado via RPC:', rpcResult[0]);
        return rpcResult[0];
      }

      console.log('‚ö†Ô∏è RPC no disponible o sin resultados, intentando consulta directa...');

      // Fallback: intentar b√∫squeda directa
      const { data, error } = await this.supabase
        .from('usuarios')
        .select('id, nombre, email')
        .ilike('email', emailNormalizado)
        .maybeSingle();

      console.log('üìä Resultado b√∫squeda directa:', { data, error });

      if (error) {
        // Si el error es por RLS, intentar un enfoque diferente
        if (error.message.includes('RLS') || error.message.includes('permission') || error.message.includes('policy')) {
          console.log('üîí Error de RLS detectado, intentando invitaci√≥n por email...');
          
          // Crear una entrada temporal o usar el email como ID temporal
          return {
            id: `temp_${emailNormalizado.replace(/[^a-zA-Z0-9]/g, '_')}`,
            email: emailNormalizado,
            nombre: emailNormalizado.split('@')[0],
            temporal: true
          };
        }
        throw error;
      }

      if (!data) {
        console.log('‚ùå Usuario no encontrado en tabla usuarios');
        throw new Error(`No se encontr√≥ un usuario registrado con el correo: ${emailNormalizado}. Aseg√∫rate de que el usuario se haya registrado en la aplicaci√≥n.`);
      }

      return data;

    } catch (error: any) {
      console.error('üí• Error en b√∫squeda de usuario:', error);
      throw error;
    }
  }

  /**
   * M√©todo auxiliar para sincronizar usuario de auth a tabla usuarios
   */
  private async sincronizarUsuarioDesdeAuth(email: string): Promise<any | null> {
    try {
      // Este m√©todo requerir√≠a permisos de admin para listar usuarios
      // Por ahora, retornamos null
      console.log('Sincronizaci√≥n de usuario desde auth no disponible sin permisos de admin');
      return null;
    } catch (error) {
      console.error('Error al sincronizar usuario desde auth:', error);
      return null;
    }
  }

  /**
   * M√©todo de debugging para verificar la estructura de la tabla usuarios
   */
  async verificarTablaUsuarios(): Promise<void> {
    try {
      const { data, error } = await this.supabase
        .from('usuarios')
        .select('*')
        .limit(5);
      
      console.log('Estructura de tabla usuarios (primeros 5 registros):', data);
      if (error) {
        console.error('Error al verificar tabla usuarios:', error);
      }
    } catch (error) {
      console.error('Error en verificaci√≥n de tabla:', error);
    }
  }
  /**
   * M√©todo mejorado para buscar usuario que incluye verificaci√≥n y sugerencias
   * Maneja pol√≠ticas RLS apropiadamente
   */
  async buscarUsuarioConVerificacion(email: string): Promise<any> {
    const emailNormalizado = email.trim().toLowerCase();
    
    console.log('üîç Iniciando b√∫squeda completa de usuario (RLS-aware):', emailNormalizado);

    try {
      // 1. Intentar con funci√≥n RPC primero (bypass RLS)
      const { data: rpcResult, error: rpcError } = await this.supabase
        .rpc('buscar_usuario_por_email', { email_busqueda: emailNormalizado });

      if (!rpcError && rpcResult && rpcResult.length > 0) {
        console.log('‚úÖ Usuario encontrado via RPC (bypass RLS)');
        return rpcResult[0];
      }

      // 2. Fallback: Buscar en tabla usuarios con manejo de RLS
      const { data: usuarioTabla, error: errorTabla } = await this.supabase
        .from('usuarios')
        .select('id, nombre, email')
        .ilike('email', emailNormalizado)
        .maybeSingle();

      console.log('üìä Resultado b√∫squeda en tabla usuarios:', { usuarioTabla, errorTabla });

      // 3. Manejar errores de RLS espec√≠ficamente
      if (errorTabla) {
        if (errorTabla.message.includes('RLS') || errorTabla.message.includes('permission') || errorTabla.message.includes('policy')) {
          console.log('üîí Error de RLS detectado. Esto es normal si las pol√≠ticas est√°n activas.');
          console.log('üí° Sugerencia: El usuario debe estar registrado pero las pol√≠ticas RLS impiden la b√∫squeda directa.');
          
          // Intentar crear una invitaci√≥n basada en email sin verificar existencia
          const toast = `‚ö†Ô∏è No se puede verificar si el usuario existe debido a las pol√≠ticas de seguridad de la base de datos. La invitaci√≥n se enviar√° al correo especificado.`;
          
          return {
            id: `email_${emailNormalizado.replace(/[^a-zA-Z0-9]/g, '_')}`,
            email: emailNormalizado,
            nombre: emailNormalizado.split('@')[0],
            rls_blocked: true,
            mensaje: toast
          };
        }
        throw errorTabla;
      }

      if (usuarioTabla) {
        console.log('‚úÖ Usuario encontrado en tabla usuarios');
        return usuarioTabla;
      }

      // 4. Si no se encuentra, buscar variaciones del email (si RLS lo permite)
      console.log('üîÑ Buscando variaciones del email...');
      
      const { data: variaciones, error: errorVariaciones } = await this.supabase
        .from('usuarios')
        .select('id, nombre, email')
        .or(`email.ilike.%${emailNormalizado}%,email.ilike.%${email}%`)
        .limit(5);

      if (!errorVariaciones && variaciones && variaciones.length > 0) {
        console.log('üéØ Usuarios similares encontrados:', variaciones);
        throw new Error(`No se encontr√≥ exactamente "${emailNormalizado}", pero hay usuarios similares. Verifica la ortograf√≠a del correo.`);
      }

      // 5. Informaci√≥n final si no se encuentra nada
      throw new Error(`El usuario con correo "${emailNormalizado}" no est√° registrado en la aplicaci√≥n. Aseg√∫rate de que se haya registrado correctamente.`);

    } catch (error: any) {
      console.error('‚ùå Error en b√∫squeda de usuario:', error);
      throw error;
    }
  }
  /**
   * Invita a un usuario a colaborar en una despensa
   * Maneja casos donde RLS impide la b√∫squeda directa de usuarios
   */
  async invitarColaboradorADespensa(despensaId: string, usuarioEmail: string, rol: string = 'editor'): Promise<void> {
    try {
      console.log('üöÄ Iniciando proceso de invitaci√≥n:', { despensaId, usuarioEmail, rol });

      // 1. Buscar al usuario por email con verificaci√≥n completa
      const usuario = await this.buscarUsuarioConVerificacion(usuarioEmail);
      
      // 2. Manejar caso especial donde RLS bloque√≥ la b√∫squeda
      if (usuario.rls_blocked) {
        console.log('üîí RLS detectado, intentando invitaci√≥n directa...');
        
        // Intentar crear invitaci√≥n usando funci√≥n RPC o m√©todo alternativo
        const { data: invitacionResult, error: invitacionError } = await this.supabase
          .rpc('invitar_colaborador_por_email', {
            p_despensa_id: despensaId,
            p_email: usuarioEmail.trim().toLowerCase(),
            p_rol: rol
          });

        if (invitacionError) {
          // Si la funci√≥n RPC no existe, intentar inserci√≥n directa
          console.log('‚ö†Ô∏è Funci√≥n RPC no disponible, intentando inserci√≥n directa...');
          throw new Error(`No se pudo invitar al usuario debido a las pol√≠ticas de seguridad. El usuario debe registrarse primero en la aplicaci√≥n con el correo: ${usuarioEmail}`);
        }

        if (invitacionResult) {
          console.log('‚úÖ Invitaci√≥n creada via RPC');
          return;
        }
      }

      // 3. Verificar que el usuario no sea el propietario
      const { data: despensa, error: errorDespensa } = await this.supabase
        .from('despensas')
        .select('propietario_id, nombre')
        .eq('id', despensaId)
        .single();

      if (errorDespensa) {
        console.error('‚ùå Error al obtener informaci√≥n de despensa:', errorDespensa);
        throw errorDespensa;
      }

      console.log('üìã Informaci√≥n de despensa:', despensa);

      if (despensa.propietario_id === usuario.id) {
        throw new Error('No puedes invitarte a ti mismo a tu propia despensa');
      }

      // 4. Verificar que el usuario no est√© ya invitado
      const { data: accesoExistente } = await this.supabase
        .from('accesos_despensa')
        .select('id, rol')
        .eq('usuario_id', usuario.id)
        .eq('despensa_id', despensaId)
        .single();

      if (accesoExistente) {
        throw new Error(`Este usuario ya tiene acceso a la despensa como ${accesoExistente.rol}`);
      }

      // 5. Crear el acceso para el colaborador
      const { error: errorAcceso } = await this.supabase
        .from('accesos_despensa')
        .insert({
          usuario_id: usuario.id,
          despensa_id: despensaId,
          rol: rol
        });

      if (errorAcceso) {
        console.error('‚ùå Error al crear acceso:', errorAcceso);
        throw errorAcceso;
      }

      console.log('‚úÖ Acceso creado exitosamente');

      // 6. Marcar la despensa como compartida
      const { error: errorUpdate } = await this.supabase
        .from('despensas')
        .update({ compartida: true })
        .eq('id', despensaId);

      if (errorUpdate) {
        console.error('‚ö†Ô∏è Advertencia: Error al marcar despensa como compartida:', errorUpdate);
        // No lanzar error aqu√≠, ya que la invitaci√≥n fue exitosa
      }

      console.log('üéâ Proceso de invitaci√≥n completado exitosamente');

    } catch (error: any) {
      console.error('üí• Error en proceso de invitaci√≥n:', error);
      throw error;
    }
  }
  /**
   * Obtiene la lista de colaboradores de una despensa
   */
  async obtenerColaboradoresDespensa(despensaId: string): Promise<any[]> {
    try {
      console.log('üîç Obteniendo colaboradores para despensa:', despensaId);
      
      // Intentar con join directo primero
      const { data, error } = await this.supabase
        .from('accesos_despensa')
        .select(`
          rol,
          usuario_id,
          usuarios (
            id,
            nombre,
            email
          )
        `)
        .eq('despensa_id', despensaId)
        .order('rol', { ascending: false }); // Propietarios primero

      if (error) {
        console.error('‚ùå Error con join directo:', error);
        
        // Si hay error RLS, usar fallback sin join
        console.log('üîÑ Intentando obtener colaboradores sin join...');
        return await this.obtenerColaboradoresSinJoin(despensaId);
      }

      console.log('‚úÖ Colaboradores obtenidos exitosamente:', data);
      return data || [];
      
    } catch (error: any) {
      console.error('üí• Error obteniendo colaboradores:', error);
      
      // Fallback sin join
      return await this.obtenerColaboradoresSinJoin(despensaId);
    }
  }

  /**
   * M√©todo fallback para obtener colaboradores sin join (para casos de RLS)
   */
  private async obtenerColaboradoresSinJoin(despensaId: string): Promise<any[]> {
    try {
      console.log('üîÑ Usando m√©todo fallback para obtener colaboradores...');
      
      // 1. Obtener solo los accesos
      const { data: accesos, error: errorAccesos } = await this.supabase
        .from('accesos_despensa')
        .select('rol, usuario_id')
        .eq('despensa_id', despensaId)
        .order('rol', { ascending: false });

      if (errorAccesos) {
        console.error('‚ùå Error obteniendo accesos:', errorAccesos);
        throw errorAccesos;
      }

      // 2. Para cada acceso, intentar obtener datos del usuario
      const colaboradoresConDatos = await Promise.all(
        (accesos || []).map(async (acceso) => {
          try {
            // Intentar obtener datos del usuario
            const { data: usuario, error: errorUsuario } = await this.supabase
              .from('usuarios')
              .select('id, nombre, email')
              .eq('id', acceso.usuario_id)
              .single();

            if (errorUsuario || !usuario) {
              console.warn(`‚ö†Ô∏è No se pudo obtener datos del usuario ${acceso.usuario_id}:`, errorUsuario);
              
              // Retornar con datos m√≠nimos si no se puede obtener el usuario
              return {
                rol: acceso.rol,
                usuario_id: acceso.usuario_id,
                usuarios: {
                  id: acceso.usuario_id,
                  nombre: 'Usuario no disponible',
                  email: 'Email no disponible'
                }
              };
            }

            return {
              rol: acceso.rol,
              usuario_id: acceso.usuario_id,
              usuarios: usuario
            };

          } catch (error) {
            console.warn(`‚ö†Ô∏è Error obteniendo usuario ${acceso.usuario_id}:`, error);
            
            // Retornar con datos m√≠nimos en caso de error
            return {
              rol: acceso.rol,
              usuario_id: acceso.usuario_id,
              usuarios: {
                id: acceso.usuario_id,
                nombre: 'Usuario no disponible',
                email: 'Email no disponible'
              }
            };
          }
        })
      );

      console.log('‚úÖ Colaboradores obtenidos con m√©todo fallback:', colaboradoresConDatos);
      return colaboradoresConDatos;

    } catch (error: any) {
      console.error('üí• Error en m√©todo fallback:', error);
      
      // En caso de error total, retornar array vac√≠o
      console.log('‚ö†Ô∏è Retornando lista vac√≠a de colaboradores');
      return [];
    }
  }

  /**
   * Elimina un colaborador de una despensa
   */
  async eliminarColaboradorDespensa(despensaId: string, usuarioId: string): Promise<void> {
    // Verificar que no sea el propietario
    const { data: despensa, error: errorDespensa } = await this.supabase
      .from('despensas')
      .select('propietario_id')
      .eq('id', despensaId)
      .single();

    if (errorDespensa) throw errorDespensa;

    if (despensa.propietario_id === usuarioId) {
      throw new Error('No puedes eliminar al propietario de la despensa');
    }

    const { error } = await this.supabase
      .from('accesos_despensa')
      .delete()
      .eq('usuario_id', usuarioId)
      .eq('despensa_id', despensaId);

    if (error) throw error;
  }

  /**
   * Actualiza el rol de un colaborador en una despensa
   */
  async actualizarRolColaborador(despensaId: string, usuarioId: string, nuevoRol: string): Promise<void> {
    const { error } = await this.supabase
      .from('accesos_despensa')
      .update({ rol: nuevoRol })
      .eq('usuario_id', usuarioId)
      .eq('despensa_id', despensaId);

    if (error) throw error;
  }
  /**
   * Verifica si el usuario actual es propietario de una despensa
   */
  async esPropietarioDespensa(despensaId: string): Promise<boolean> {
    try {
      const user = await this.supabase.auth.getUser();
      const userId = user.data.user?.id;
      if (!userId) {
        console.log('‚ùå No hay usuario autenticado');
        return false;
      }

      console.log('üîç Verificando si usuario es propietario:', { userId, despensaId });

      const { data, error } = await this.supabase
        .from('despensas')
        .select('propietario_id')
        .eq('id', despensaId)
        .single();

      if (error) {
        console.error('‚ùå Error verificando propietario:', error);
        
        // Fallback: verificar en accesos_despensa
        console.log('üîÑ Intentando fallback con accesos_despensa...');
        const { data: acceso, error: errorAcceso } = await this.supabase
          .from('accesos_despensa')
          .select('rol')
          .eq('usuario_id', userId)
          .eq('despensa_id', despensaId)
          .eq('rol', 'propietario')
          .single();

        if (errorAcceso) {
          console.error('‚ùå Error en fallback:', errorAcceso);
          return false;
        }

        return acceso !== null;
      }

      const esPropietario = data.propietario_id === userId;
      console.log('‚úÖ Resultado verificaci√≥n propietario:', esPropietario);
      return esPropietario;

    } catch (error: any) {
      console.error('üí• Error verificando propietario:', error);
      return false;
    }
  }
  /**
   * Obtiene el rol del usuario actual en una despensa
   */
  async obtenerRolEnDespensa(despensaId: string): Promise<string | null> {
    try {
      const user = await this.supabase.auth.getUser();
      const userId = user.data.user?.id;
      if (!userId) {
        console.log('‚ùå No hay usuario autenticado');
        return null;
      }

      console.log('üîç Obteniendo rol del usuario:', { userId, despensaId });

      const { data, error } = await this.supabase
        .from('accesos_despensa')
        .select('rol')
        .eq('usuario_id', userId)
        .eq('despensa_id', despensaId)
        .single();

      if (error) {
        console.error('‚ùå Error obteniendo rol:', error);
        
        // Si hay error, intentar verificar si es propietario directo
        console.log('üîÑ Verificando si es propietario directo...');
        const { data: despensa, error: errorDespensa } = await this.supabase
          .from('despensas')
          .select('propietario_id')
          .eq('id', despensaId)
          .single();

        if (!errorDespensa && despensa && despensa.propietario_id === userId) {
          console.log('‚úÖ Usuario es propietario directo');
          return 'propietario';
        }

        console.log('‚ùå No se pudo determinar el rol');
        return null;
      }

      console.log('‚úÖ Rol obtenido:', data.rol);
      return data.rol;

    } catch (error: any) {
      console.error('üí• Error obteniendo rol:', error);
      return null;
    }
  }

  /**
   * M√©todo para diagnosticar problemas de sincronizaci√≥n de usuarios
   * √ötil cuando un usuario existe en auth pero no en la tabla usuarios
   */
  async diagnosticarProblemasUsuarios(): Promise<{
    totalUsuarios: number;
    ejemplosUsuarios: any[];
    sugerencias: string[];
  }> {
    try {
      console.log('üî¨ Iniciando diagn√≥stico de usuarios...');

      // 1. Contar usuarios en la tabla
      const { count, error: errorCount } = await this.supabase
        .from('usuarios')
        .select('*', { count: 'exact', head: true });

      // 2. Obtener algunos ejemplos de usuarios
      const { data: ejemplos, error: errorEjemplos } = await this.supabase
        .from('usuarios')
        .select('id, nombre, email, created_at')
        .limit(5);

      const sugerencias = [
        'Verifica que el usuario se haya registrado correctamente en la aplicaci√≥n',
        'Aseg√∫rate de que el proceso de registro incluya la inserci√≥n en la tabla usuarios',
        'Revisa si hay diferencias de may√∫sculas/min√∫sculas en el email',
        'Confirma que no hay espacios en blanco al inicio o final del email'
      ];

      if (count === 0) {
        sugerencias.push('‚ö†Ô∏è No hay usuarios en la tabla. Revisa el proceso de registro.');
      }

      console.log('üìä Diagn√≥stico completado:', {
        totalUsuarios: count,
        ejemplosUsuarios: ejemplos,
        sugerencias
      });

      return {
        totalUsuarios: count || 0,
        ejemplosUsuarios: ejemplos || [],
        sugerencias
      };

    } catch (error) {
      console.error('‚ùå Error en diagn√≥stico:', error);
      return {
        totalUsuarios: 0,
        ejemplosUsuarios: [],
        sugerencias: ['Error al acceder a la base de datos. Verifica la conexi√≥n.']
      };
    }
  }

  /**
   * M√©todo de diagn√≥stico para verificar conectividad y pol√≠ticas RLS
   */
  async diagnosticarConectividadRLS(): Promise<any> {
    console.log('üîß Iniciando diagn√≥stico de conectividad y RLS...');
    
    try {
      const resultados = {
        auth: false,
        tablaUsuarios: false,
        tablaAccesos: false,
        funcionesRPC: false,
        rlsActivo: false,
        errores: [] as string[]
      };

      // 1. Verificar autenticaci√≥n
      const { data: authData, error: authError } = await this.supabase.auth.getUser();
      if (authError || !authData.user) {
        resultados.errores.push('‚ùå Error de autenticaci√≥n: ' + (authError?.message || 'Sin usuario'));
      } else {
        resultados.auth = true;
        console.log('‚úÖ Usuario autenticado:', authData.user.email);
      }

      // 2. Verificar tabla usuarios
      try {
        const { data, error } = await this.supabase
          .from('usuarios')
          .select('id')
          .limit(1);
        
        if (error) {
          resultados.errores.push('‚ùå Error acceso tabla usuarios: ' + error.message);
          if (error.message.includes('RLS') || error.message.includes('policy')) {
            resultados.rlsActivo = true;
          }
        } else {
          resultados.tablaUsuarios = true;
          console.log('‚úÖ Acceso a tabla usuarios OK');
        }
      } catch (e: any) {
        resultados.errores.push('‚ùå Excepci√≥n tabla usuarios: ' + e.message);
      }

      // 3. Verificar tabla accesos_despensa
      try {
        const { data, error } = await this.supabase
          .from('accesos_despensa')
          .select('id')
          .limit(1);
        
        if (error) {
          resultados.errores.push('‚ùå Error acceso tabla accesos: ' + error.message);
          if (error.message.includes('RLS') || error.message.includes('policy')) {
            resultados.rlsActivo = true;
          }
        } else {
          resultados.tablaAccesos = true;
          console.log('‚úÖ Acceso a tabla accesos_despensa OK');
        }
      } catch (e: any) {
        resultados.errores.push('‚ùå Excepci√≥n tabla accesos: ' + e.message);
      }

      // 4. Verificar funciones RPC
      try {
        const { data, error } = await this.supabase
          .rpc('buscar_usuario_por_email', { email_busqueda: 'test@test.com' });
        
        if (error) {
          if (error.message.includes('does not exist') || error.message.includes('404')) {
            resultados.errores.push('‚ùå Funci√≥n RPC no existe - requiere despliegue SQL');
          } else {
            resultados.errores.push('‚ùå Error funci√≥n RPC: ' + error.message);
          }
        } else {
          resultados.funcionesRPC = true;
          console.log('‚úÖ Funciones RPC disponibles');
        }
      } catch (e: any) {
        resultados.errores.push('‚ùå Excepci√≥n funci√≥n RPC: ' + e.message);
      }

      console.log('üìä Resultados diagn√≥stico:', resultados);
      return resultados;
      
    } catch (error: any) {
      console.error('üí• Error en diagn√≥stico:', error);
      return {
        auth: false,
        tablaUsuarios: false,
        tablaAccesos: false,
        funcionesRPC: false,
        rlsActivo: false,
        errores: ['Error general: ' + error.message]
      };
    }
  }

  /**
   * SISTEMA DE INVITACIONES EN LA APP (sin email)
   */

  /**
   * Crea una invitaci√≥n para colaborar (sin env√≠o de email)
   */
  async crearInvitacionColaborador(despensaId: string, emailInvitado: string, rol: string = 'editor', mensaje?: string): Promise<void> {
    try {
      console.log('üì® Creando invitaci√≥n para colaborador:', { despensaId, emailInvitado, rol });

      // 1. Verificar que el usuario actual es propietario
      const esPropietario = await this.esPropietarioDespensa(despensaId);
      if (!esPropietario) {
        throw new Error('Solo el propietario puede enviar invitaciones');
      }

      // 2. Obtener ID del propietario
      const { data: { user } } = await this.supabase.auth.getUser();
      if (!user) {
        throw new Error('Usuario no autenticado');
      }

      // 3. Verificar si ya existe una invitaci√≥n pendiente
      const { data: invitacionExistente, error: errorVerificacion } = await this.supabase
        .from('invitaciones_despensa')
        .select('id, estado')
        .eq('despensa_id', despensaId)
        .eq('email_invitado', emailInvitado.toLowerCase())
        .eq('estado', 'pendiente')
        .single();

      if (invitacionExistente) {
        throw new Error('Ya existe una invitaci√≥n pendiente para este usuario');
      }

      // 4. Intentar obtener el usuario_id si el usuario ya est√° registrado
      let usuarioInvitadoId = null;
      try {
        const { data: usuarioExistente } = await this.supabase
          .from('usuarios')
          .select('id')
          .eq('email', emailInvitado.toLowerCase())
          .single();
        
        if (usuarioExistente) {
          usuarioInvitadoId = usuarioExistente.id;
        }
      } catch (e) {
        // No hay problema si no encontramos el usuario, se registrar√° despu√©s
        console.log('üë§ Usuario no registrado a√∫n, invitaci√≥n por email:', emailInvitado);
      }

      // 5. Crear la invitaci√≥n
      const { error: errorInvitacion } = await this.supabase
        .from('invitaciones_despensa')
        .insert({
          despensa_id: despensaId,
          email_invitado: emailInvitado.toLowerCase(),
          usuario_invitado_id: usuarioInvitadoId,
          propietario_id: user.id,
          rol: rol,
          mensaje: mensaje || `Te han invitado a colaborar en una despensa como ${rol}`
        });

      if (errorInvitacion) {
        console.error('‚ùå Error creando invitaci√≥n:', errorInvitacion);
        throw errorInvitacion;
      }

      console.log('‚úÖ Invitaci√≥n creada exitosamente');

    } catch (error: any) {
      console.error('üí• Error en crearInvitacionColaborador:', error);
      throw error;
    }
  }

  /**
   * Obtiene las invitaciones pendientes para el usuario actual
   */  async obtenerInvitacionesPendientes(): Promise<any[]> {
    try {
      console.log('üì• Obteniendo invitaciones pendientes...');

      // Usar funci√≥n RPC si est√° disponible
      try {
        const { data: rpcResult, error: rpcError } = await this.supabase
          .rpc('obtener_invitaciones_pendientes');

        if (!rpcError && rpcResult) {
          console.log('‚úÖ Invitaciones obtenidas via RPC:', rpcResult);
          
          // Diagnosticar la estructura de datos que viene de la funci√≥n RPC
          if (rpcResult && rpcResult.length > 0) {
            console.log('üîç Estructura de invitaci√≥n RPC:', Object.keys(rpcResult[0]).join(', '));
          }
          
          // Aseg√∫rese de que cada elemento tenga un campo 'id'
          return rpcResult.map((inv: any) => {
            // Crear una copia para no mutar la original
            const normalizedInv = { ...inv };
            
            // Aseguramos que todos los campos requeridos existan para evitar errores
            if (!normalizedInv.id && normalizedInv.invitacion_id) {
              normalizedInv.id = normalizedInv.invitacion_id;
              console.log('‚úÖ Copiando invitacion_id a id:', normalizedInv.id);
            }
            
            // Asegurar que el ID sea accesible
            if (!normalizedInv.id) {
              console.warn('‚ö†Ô∏è Invitaci√≥n sin ID, creando ID temporal para referencia local');
              // UUID v4 generado con Date.now() y Math.random() como fallback
              const uuid = 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
                const r = (Date.now() + Math.random()*16)%16 | 0;
                return (c === 'x' ? r : (r&0x3|0x8)).toString(16);
              });
              normalizedInv.id = uuid;
              normalizedInv._generatedId = true; // Marcar para saber que es generado
            }
            
            // Normalizar nombres para la interfaz
            if (!normalizedInv.despensa_nombre && normalizedInv.nombre_despensa) {
              normalizedInv.despensa_nombre = normalizedInv.nombre_despensa;
            }
            
            if (!normalizedInv.propietario_nombre && normalizedInv.nombre_propietario) {
              normalizedInv.propietario_nombre = normalizedInv.nombre_propietario;
            }
            
            return normalizedInv;
          });
        }
      } catch (e) {
        console.log('‚ö†Ô∏è Funci√≥n RPC no disponible, usando fallback:', e);
      }

      // Fallback: consulta directa
      const { data: { user } } = await this.supabase.auth.getUser();
      if (!user) {
        throw new Error('Usuario no autenticado');
      }

      const { data, error } = await this.supabase
        .from('invitaciones_despensa')
        .select(`
          id,
          despensa_id,
          rol,
          mensaje,
          fecha_invitacion,
          despensas (
            nombre
          ),
          usuarios:propietario_id (
            nombre,
            email
          )
        `)
        .eq('estado', 'pendiente')
        .or(`email_invitado.eq.${user.email},usuario_invitado_id.eq.${user.id}`)
        .order('fecha_invitacion', { ascending: false });

      if (error) {
        console.error('‚ùå Error obteniendo invitaciones:', error);
        throw error;
      }

      console.log('‚úÖ Invitaciones obtenidas:', data);
      return data || [];

    } catch (error: any) {
      console.error('üí• Error en obtenerInvitacionesPendientes:', error);
      throw error;
    }
  }

  /**
   * Acepta una invitaci√≥n de colaboraci√≥n
   */  async aceptarInvitacion(invitacionId: string): Promise<any> {
    try {
      console.log('‚úÖ Aceptando invitaci√≥n:', invitacionId);

      // Verificar que el ID sea un UUID v√°lido
      if (!invitacionId || typeof invitacionId !== 'string') {
        throw new Error('ID de invitaci√≥n inv√°lido o no proporcionado');
      }

      // Verificar formato UUID v√°lido
      const uuidPattern = /^[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}$/i;
      if (!uuidPattern.test(invitacionId)) {
        console.warn('‚ö†Ô∏è ID de invitaci√≥n no tiene formato UUID v√°lido:', invitacionId);
        throw new Error('ID de invitaci√≥n no tiene formato v√°lido');
      }

      // Intentar primero v√≠a m√©todo directo (m√°s confiable)
      try {
        console.log('üîÑ Intentando aceptaci√≥n manual de invitaci√≥n...');
        const { data: invData, error: selectError } = await this.supabase
          .from('invitaciones_despensa')
          .select('*')
          .eq('id', invitacionId)
          .single();
          
        if (selectError) {
          console.error('‚ùå Error consultando invitaci√≥n:', selectError);
          throw selectError;
        }
          
        if (!invData) {
          throw new Error('No se encontr√≥ la invitaci√≥n');
        }
        
        console.log('üìã Datos de invitaci√≥n encontrados:', invData);
        
        const userId = (await this.supabase.auth.getUser()).data.user?.id;
        if (!userId) {
          throw new Error('Usuario no autenticado');
        }
        
        // Insertar acceso manualmente
        const { error: errorAcceso } = await this.supabase
          .from('accesos_despensa')
          .insert({
            usuario_id: userId,
            despensa_id: invData.despensa_id,
            rol: invData.rol
          });
          
        if (errorAcceso) throw errorAcceso;
        
        // Actualizar la invitaci√≥n como aceptada
        const { error: errorUpdate } = await this.supabase
          .from('invitaciones_despensa')
          .update({ 
            estado: 'aceptada',
            fecha_respuesta: new Date().toISOString(),
            usuario_invitado_id: userId
          })
          .eq('id', invitacionId);
          
        if (errorUpdate) throw errorUpdate;
        
        // Actualizar despensa como compartida
        const { error: errorDespensa } = await this.supabase
          .from('despensas')
          .update({ compartida: true })
          .eq('id', invData.despensa_id);
          
        if (errorDespensa) {
          console.warn('‚ö†Ô∏è No se pudo marcar la despensa como compartida:', errorDespensa);
          // No bloqueamos por este error
        }
        
        return {
          success: true,
          message: 'Invitaci√≥n aceptada exitosamente',
          despensa_id: invData.despensa_id,
          rol: invData.rol
        };
      } catch (directError: any) {
        console.error('‚ùå Error en m√©todo directo:', directError);
        
        // Solo intentamos el m√©todo RPC si el directo falla
        console.log('üîÑ Fallback: Intentando aceptar invitaci√≥n v√≠a RPC...');
        
        const { data, error } = await this.supabase
          .rpc('aceptar_invitacion_despensa', { 
            p_invitacion_id: invitacionId 
          });

        if (error) {
          console.error('‚ùå Error aceptando invitaci√≥n v√≠a RPC:', error);
          throw new Error(`Error con la funci√≥n RPC: ${error.message}`);
        }

        if (data && !data.success) {
          throw new Error(data.error || 'Error aceptando invitaci√≥n');
        }

        console.log('‚úÖ Invitaci√≥n aceptada exitosamente v√≠a RPC:', data);
        return data;
      }    } catch (error: any) {
      console.error('üí• Error global en aceptarInvitacion:', error);
      throw error;
    }

    } catch (error: any) {
      console.error('üí• Error en aceptarInvitacion:', error);
      throw error;
    }
  }

  /**
   * Rechaza una invitaci√≥n de colaboraci√≥n
   */
  async rechazarInvitacion(invitacionId: string): Promise<any> {
    try {
      console.log('‚ùå Rechazando invitaci√≥n:', invitacionId);

      // Usar funci√≥n RPC si est√° disponible
      const { data, error } = await this.supabase
        .rpc('rechazar_invitacion_despensa', { p_invitacion_id: invitacionId });

      if (error) {
        console.error('‚ùå Error rechazando invitaci√≥n:', error);
        throw error;
      }

      if (data && !data.success) {
        throw new Error(data.error || 'Error rechazando invitaci√≥n');
      }

      console.log('‚úÖ Invitaci√≥n rechazada exitosamente:', data);
      return data;

    } catch (error: any) {
      console.error('üí• Error en rechazarInvitacion:', error);
      throw error;
    }
  }

  /**
   * Obtiene el conteo de invitaciones pendientes
   */
  async contarInvitacionesPendientes(): Promise<number> {
    try {
      const invitaciones = await this.obtenerInvitacionesPendientes();
      return invitaciones.length;
    } catch (error) {
      console.error('Error contando invitaciones:', error);
      return 0;
    }
  }
}